<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Notes</title><link href="https://aphasiayc.github.io/" rel="alternate"></link><link href="https://aphasiayc.github.io/feeds/all.atom.xml" rel="self"></link><id>https://aphasiayc.github.io/</id><updated>2019-05-25T23:08:28+08:00</updated><entry><title>xv6: minimal assembly</title><link href="https://aphasiayc.github.io/2019/xv6-minimal-assembly.html" rel="alternate"></link><published>2019-05-25T23:08:28+08:00</published><updated>2019-05-25T23:08:28+08:00</updated><author><name>aphasiayc</name></author><id>tag:aphasiayc.github.io,2019-05-25:/2019/xv6-minimal-assembly.html</id><summary type="html">&lt;p&gt;和现代操作系统比起来，xv6基本只能算是个复古风格的玩具模型。它仿照unix version 6设计，不涉及现代操作系统中各种复杂的优化。但好处是简单明了，码工精美，十分适合作为我等初级选手的入门教程。&lt;/p&gt;
&lt;p&gt;xv6适用于多核x86系统，主要使用ANSI C（以及少量AT&amp;amp;T风格的汇编语言）编码。我在阅读源码过程中最初的障碍来源于对硬件和汇编的无知，所以在此先补一篇相关基础知识的笔记。&lt;/p&gt;
&lt;h2&gt;寄存器&lt;/h2&gt;
&lt;p&gt;CPU包含若干组寄存器，xv6涉及到的主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;8个general purpose registers：%eax、%ebx、%ecx、%edx、%edi、%esi、%ebp、%esp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依据惯例，寄存器名称中的&lt;code&gt;e&lt;/code&gt;代表extended，标明其长度为32位。它们较低的16位分别可以通过%ax、%bx、%cx、%dx、%di、%si、%bp、%sp访问。修改%ax即修改%eax，反之也对。更近一步 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;和现代操作系统比起来，xv6基本只能算是个复古风格的玩具模型。它仿照unix version 6设计，不涉及现代操作系统中各种复杂的优化。但好处是简单明了，码工精美，十分适合作为我等初级选手的入门教程。&lt;/p&gt;
&lt;p&gt;xv6适用于多核x86系统，主要使用ANSI C（以及少量AT&amp;amp;T风格的汇编语言）编码。我在阅读源码过程中最初的障碍来源于对硬件和汇编的无知，所以在此先补一篇相关基础知识的笔记。&lt;/p&gt;
&lt;h2&gt;寄存器&lt;/h2&gt;
&lt;p&gt;CPU包含若干组寄存器，xv6涉及到的主要有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;8个general purpose registers：%eax、%ebx、%ecx、%edx、%edi、%esi、%ebp、%esp&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依据惯例，寄存器名称中的&lt;code&gt;e&lt;/code&gt;代表extended，标明其长度为32位。它们较低的16位分别可以通过%ax、%bx、%cx、%dx、%di、%si、%bp、%sp访问。修改%ax即修改%eax，反之也对。更近一步，%ax、%bx、%cx、%dx较高的8位可以通过%ah、%bh、%ch、%dh，较低的8位可以通过%al、%bl、%cl、%dl。&lt;/p&gt;
&lt;p&gt;其中比较特殊的是%esp（stack pointer，指向栈的最低位置）和%ebp（base pointer，在函数过程中指示frame的起始位置）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1个instruction pointer：%eip&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;32位。%eip存储program counter，指向当前指令开始的位置。%eip通常不能直接操作，需要通过&lt;a href="#control-flow-instructions"&gt;control flow instructions&lt;/a&gt;来控制。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4个control registers：%cr0、%cr2、%cr3、%cr4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;32位。在xv6中主要用于支持内存分页。%cr0用于存储一系列标识内存状态的flag，%cr3用于存储分页表地址，%cr4用于控制分页大小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;6个segment registers：%cs、%ss、%ds、%es、%fs、%gs&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;16位。包括%cs（code segment），%ss（stack segment），%ds（data segment）等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3个descriptor registers：%gdtr、%ldtr、%idtr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;16位。%gdtr、%ldtr用于访问segment descriptor table（SDT），%idtr用于访问interrupt descriptor table（IDT）。&lt;/p&gt;
&lt;p&gt;另外还有若干专用的寄存器，例如%eflags用于存储若干CPU状态相关的标志位、%tr用于指示task state segment等。&lt;/p&gt;
&lt;p&gt;xv6没有涉及用于浮点数运算、debug和测试等的寄存器。&lt;/p&gt;
&lt;h2&gt;内存&lt;/h2&gt;
&lt;p&gt;主内存访问速度比寄存器慢10&lt;sup&gt;2&lt;/sup&gt;倍。x86系统支持32位地址，可以用于访问4 GB内存空间。&lt;/p&gt;
&lt;h3&gt;静态数据&lt;/h3&gt;
&lt;p&gt;静态数据可以通过它们在声明时设定的label访问。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;.data&lt;/span&gt;

&lt;span class="nl"&gt;x:&lt;/span&gt;
    &lt;span class="na"&gt;.word&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;        &lt;span class="c"&gt;# 常数&lt;/span&gt;

&lt;span class="nl"&gt;array:&lt;/span&gt;
    &lt;span class="na"&gt;.long&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;   &lt;span class="c"&gt;# 数组&lt;/span&gt;

&lt;span class="nl"&gt;str:&lt;/span&gt;
    &lt;span class="na"&gt;.string&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt; &lt;span class="c"&gt;# 字符串&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;访问方式&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;addressed by register: (%eax)&lt;/p&gt;
&lt;p&gt;with offset: -4(%eax), memory addressed by %eax-4&lt;/p&gt;
&lt;p&gt;simple arithmetic: (%esi, %eax, 4), memory addressed by %esi+4*%eax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;长度后缀&lt;/h3&gt;
&lt;p&gt;当操作所涉及的数据长度存在多种可能的时候，必须用后缀标明。可用的后缀包括&lt;code&gt;b&lt;/code&gt;（byte）、&lt;code&gt;w&lt;/code&gt;（word，2 bytes）和&lt;code&gt;l&lt;/code&gt;（long，4 bytes）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mov: movb、movw、movl&lt;/p&gt;
&lt;p&gt;add: addb、addw、addl&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;指令&lt;/h2&gt;
&lt;h3&gt;data movement instructions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mov &amp;lt;src&amp;gt; &amp;lt;dst&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;mov&lt;/code&gt;将&amp;lt;src&amp;gt;中的数据复制到&amp;lt;dst&amp;gt;。数据可以在两个寄存器之间、寄存器和内存之间移动，但不能直接在两个内存地址之间移动。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;mov %esi, %eax: move value stored in %esi to %eax&lt;/p&gt;
&lt;p&gt;mov (%esi), %eax: move value stored at the memory position indexed by %esi to %eax&lt;/p&gt;
&lt;p&gt;mov $1, %eax: move value 1 to %eax&lt;/p&gt;
&lt;p&gt;movb $1, (%esi): move one byte value of 1 to the memory position indexed by %esi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;push &amp;lt;val&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;push&lt;/code&gt;指令首先将%esp中的数值减4，然后将&amp;lt;val&amp;gt;复制到%esp指向的内存地址&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;push %eax: push value stored in %eax onto stack&lt;/p&gt;
&lt;p&gt;push (%eax): push value stored at the memory position indexed by %eax onto stack&lt;/p&gt;
&lt;p&gt;push $1: push value 1 onto stack&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;pop &amp;lt;addr&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;pop&lt;/code&gt;指令将%esp指向的内存中的数据（4 bytes）复制到&amp;lt;addr&amp;gt;中，然后将%esp中的数值加4。&amp;lt;addr&amp;gt;可以是寄存器或内存地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;pop %eax: pop value on top of stack to %eax&lt;/p&gt;
&lt;p&gt;pop (%eax): pop value on top of stack to the memory position indexed by %eax&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;arithmetic &amp;amp; logic instructions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;add/sub&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;inc/dec&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;imul&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;idiv&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;and/or/xor&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a name="control-flow-instructions"&gt;&lt;/a&gt;control flow instructions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;jmp &amp;lt;label&amp;gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cmp &amp;amp; j&lt;em&gt;condition&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;call &amp;lt;label&amp;gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;call&lt;/code&gt;首先将返回后将下一个指令（即函数返回后将要执行的指令）的地址压栈（称此地址为return address），然后跳转到&amp;lt;label&amp;gt;指向的指令位置。&lt;/p&gt;
&lt;p&gt;return address指向%eip+sizeof(call instruction)的位置。在跨segment调用（即所谓far call）的情况下，return address也包含当前指令所属的segment（%cs）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ret&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;ret&lt;/code&gt;从栈上弹出跳转之前的指令位置，跳转回这个位置。&lt;/p&gt;
&lt;h2&gt;调用规则&lt;/h2&gt;
&lt;p&gt;C语言的函数调用过程将栈切分成若干frame，每个函数各自维护一个frame。在当前函数的frame中，%ebp指示frame的起始位置（因此%ebp被称为base pointer），而%esp指示栈的底端，即frame的结束位置。&lt;/p&gt;
&lt;p&gt;函数调用时，主调和被调函数都需要遵从一定的规则。&lt;/p&gt;
&lt;h3&gt;caller rules&lt;/h3&gt;
&lt;p&gt;在调用之前，主调函数需要做一些准备工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;被调函数可能会修改寄存器内容，所以在执行之前需要先备份寄存器状态。根据约定，主调函数负责%eax，%ecx，%edx。&lt;/li&gt;
&lt;li&gt;将函数参数压栈（x86 64bit有了更多寄存器，当参数不多的时候可以直接通过寄存器传参）。&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;call&lt;/code&gt;，上文提过，&lt;code&gt;call&lt;/code&gt;会将返回之后将要运行的指令位置压栈，然后执行一个无条件跳转。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从被调函数返回之后，继续执行当前控制流指令之前，主调函数需要做一些清理工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将函数参数从栈上移除。&lt;/li&gt;
&lt;li&gt;将之前备份过的%eax、%ecx、%edx中的数据从栈上取出，还原到相应寄存器中。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;callee rules&lt;/h3&gt;
&lt;p&gt;被调过程在执行自己的指令之前，同样需要做一些准备工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开始执行被调函数之前，需要在栈上为它分配一个新的frame。具体的操作是将%ebp中的内容（主调函数对应frame的base）备份到栈上，然后令%ebp指向%esp的位置（当前过程对应的frame的base）。&lt;/li&gt;
&lt;li&gt;在栈上为局域变量分配空间&lt;/li&gt;
&lt;li&gt;备份寄存器上的数据，按照约定%ebx、%edi、%esi由被调函数负责。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在被调过程返回之前，也有一些收尾工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将返回值存储在%eax中。&lt;/li&gt;
&lt;li&gt;将之前备份过的%ebx、%edi、%esi中的数据还原。&lt;/li&gt;
&lt;li&gt;移除局域变量。这可以通过令%esp指向%ebp（当前过程对应frame的起始位置）实现。&lt;/li&gt;
&lt;li&gt;清除当前frame，将之前备份过的主调函数的frame base值从栈上弹出，还原到%ebp中。&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;ret&lt;/code&gt;指令，上文提过&lt;code&gt;ret&lt;/code&gt;将从栈上弹出一个指令位置，并无条件跳转到这个位置处。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4&gt;参考：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://flint.cs.yale.edu/cs421/papers/x86-asm/asm.html"&gt;x86 Assembly Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://pdos.csail.mit.edu/6.828/2012/xv6/book-rev7.pdf"&gt;xv6 Book&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content></entry></feed>